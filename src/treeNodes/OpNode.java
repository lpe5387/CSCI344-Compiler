package treeNodes; /**
 * This class is responsible for the operation node for the parse tree
 *
 * @author Luka Eaton Issac Kim lucie lim
 */

import exceptions.SyntaxException;
import provided.JottTree;
import provided.Token;
import provided.TokenType;

import java.util.ArrayList;

public class OpNode implements JottTree {

    private Token token;

    public OpNode(Token token){
        this.token = token;
    }

    /**
     * Function to parse a relational operator for the parse tree.
     * @param tokenlist the list of tokens generated by the Tokenizer
     * @return treeNodes.OpNode
     * @throws SyntaxException
     */
    public static OpNode parseOp(ArrayList<Token> tokenlist) throws SyntaxException {
        if(!tokenlist.isEmpty()) {
            Token token = tokenlist.get(0);
            TokenType tokenType = token.getTokenType();
            if (tokenType == TokenType.REL_OP || tokenType == TokenType.MATH_OP) {
                OpNode node = new OpNode(token);
                tokenlist.remove(0);
                return node;
            } else {
                throw new SyntaxException("Expected a Relational Operator, got " + token.getToken(), token.getFilename(), token.getLineNum());
            }
        }
        else throw new SyntaxException("Unexpected end of file");
    }

    public String convertToJott(){
        return this.token.getToken();}

    public String convertToJava(String className){
        return this.token.getToken();
    }

    public String convertToC(){return "";}

    public String convertToPython(){
        return this.token.getToken();
    }
    
    public boolean validateTree(){return true;}

    public Token getToken() {
        return this.token;
    }
}
